Duplicating a translatable model in another database
====================================================

.. versionadded:: 2.x

Overview
--------

The design of Django-Parler enforces the principle that saving a translatable models saves **all** translations.

On the other hand, duplicating a regular model in another database is typically done, as per Django documentation, by saving to another database after setting the primary key to None:

.. code-block:: python

    obj = MyRegularModel(...)
    obj.save(using="my_db")
    # possibly modify obj
    obj.pk = None  # to force insertion of a new model, not update of an existing one which
                   # would happen to have the same primary-key in the new database.
    obj.save(using="my_other_db")   # Model is inserted, new primary key is generated by the
                                    # new db engine.
                                    # Instance is now implicitly associated with my_other_db.

For translatable models, this ``save()`` paradigm works in the current database, because only modified translations must be saved, but cannot possibly be extended to duplicating into another database without the original ``pk`` being available: all translations must be fetched from the original (using the original ``pk`` database before saving to the new one.

In order to preserve the original pk until all data to be saved is actually retrieved from the original databases, several solutions can be envisioned:

* Requiring the user not to set the pk to None before calling ``save(using="my_other_db")``. That would break the user experience consistency, since it should result, as per Django documentation, in updating an existing model in the new base, if any exists with the same pk.

* Somehow caching the primary key, in order to be able to retrieve it when detecting during save() that a duplication in another database is happening (ie. that pk is None, the model was already saved in a database and the destination database is different from the original database.  This could be done, but would introduce more complexity in the ``TranslatableModelMixin.save()``, ``TranslatableModelMixin.save_translations()``, ``TranslatedFieldMixin.save()`` methods which are already subtle enough, and moving from this option to the next would break application using the feature.

* Provide a dedicated method ``duplicate_into(db_alias:str)`` for duplication, and decline to save in the ``save()`` method when duplication is detected. This option isolates the duplication feature from the regular ``save()``, and allows for supporting duplication in the save() method in the future (by detecting and deferring to ``duplicate_into()``), without breaking existing applications. Moreover, performance is much more critical on regular ``save()`` than on duplication, which is mostly an exceptional event.